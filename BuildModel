import numpy as np
import math as m
import os
import sys
from os import listdir
import matplotlib.pyplot as plt
import matplotlib as mpl
from mpl_toolkits.mplot3d import Axes3D 
from sklearn.cluster import KMeans
import imp
import ControlMesh as cm
imp.reload(cm)
cwd=os.getcwd()
sys.path.append(cwd)
#Requires a minimum build of texgen and a path pointing to Python libraries
TexGenPath='C:\\Python27\\Lib\\site-packages\\TexGen'
sys.path.append(TexGenPath)

from TexGen.Core import*
class Yarns: # This class, after initialisation, takes sections using InsertSection and either creates a new yarn in the tree or updates an existing one

   def __init__(self,Index):
      self.Index=Index
      self.Type=None
      self.Sections={} #Each yarn has a section list assigned to it. 
      self.Nodes=MasterNode(0,None,None,None,None) # Empty node class
      self.Length=0
      self.left=None
      self.right=None


   def InsertSection(self,Index,Section): #Recursive method which adds data to corresponding yarn and section 

      if isinstance(self.Index, int):
         
         if Index<self.Index:

           if self.left is None:
              self.left=Yarns(Index)              
              self.left.Sections[Section.Index]=Section
              #print 'Left insert:'+str(Index)
           else:
              self.left.InsertSection(Index,Section)

         elif Index>self.Index:

           if self.right is None:
              self.right=Yarns(Index)
              self.right.Sections[Section.Index]=Section
              #print 'Right insert:'+str(Index)
           else:
              self.right.InsertSection(Index,Section)

         elif Index==self.Index:

           try:
             #print 'New Insert'
             self.Sections[Section.Index].Insert(Section)             
           except KeyError:
             self.Sections[Section.Index]=Section  
                   
           for S in self.Sections:

              if self.Sections[S].CountNodes(0)>1:
                  Min=self.Sections[S].FindMin()
                  Max=self.Sections[S].FindMax()
                  #print Min,Max             
                  self.Sections[S].UpdatePositions(Min.Slice,Max.Slice)

      elif self.Index==None:
         self.Index=Index
         try:
           self.Sections[Section.Index].Insert(Section)
         except KeyError:
           self.Sections[Section.Index]=Section

   def AddMasterNodes(self): # Called after data insertion is finalised

      if self.left:
        self.left.AddMasterNodes()

      for S in self.Sections:
         MaxS=self.Sections[S].FindMax()
         MinS=self.Sections[S].FindMin()
         m0x=np.sum(MinS.Polygon[:,0])/len(MinS.Polygon[:,0])
         m0y=np.sum(MinS.Polygon[:,1])/len(MinS.Polygon[:,1])
         m1x=np.sum(MaxS.Polygon[:,0])/len(MaxS.Polygon[:,0])
         m1y=np.sum(MaxS.Polygon[:,1])/len(MaxS.Polygon[:,1])
         mx=(m0x+m1x)/2
         my=(m0y+m1y)/2
         if self.Sections[S].Direction in ['X','x']:
            self.Type='Warp'
            m0=np.array([MinS.Slice,mx,my])
            m1=np.array([MaxS.Slice,mx,my])
            t=np.array([1.0,0.0,0.0])
            up=np.array([0.0,0.0,1.0])
            M0=MasterNode(0,m0,0.0,t,up)
            M1=MasterNode(1,m1,0.0,t,up)    
         elif self.Sections[S].Direction in ['Y','y']:
            self.Type='Weft'
            m0=np.array([mx,MinS.Slice,my])
            m1=np.array([mx,MaxS.Slice,my])
            t=np.array([0.0,1.0,0.0])
            up=np.array([0.0,0.0,1.0])
            M0=MasterNode(0,m0,0.0,t,up)
            M1=MasterNode(1,m1,0.0,t,up)
         elif self.Sections[S].Direction in ['Z','z']:
            self.Type='Binder'
            if self.Sections[S].Sign:
               if S<0:
                 x=m1x
                 y=m1y
               else:
                 x=m0x
                 y=m0y                    
               m0=np.array([x,y,MinS.Slice])
               m1=np.array([x,y,MaxS.Slice])
               t=np.array([0.0,0.0,1.0])              
               up=np.array([0.0,-1.0,0.0])                 
               M0=MasterNode(0,m0,0.0,t,up)
               M1=MasterNode(1,m1,0.0,t,up) 
            else:
               if S<0:
                 x=m1x
                 y=m1y
               else:
                 x=m0x
                 y=m0y 
                               
               m0=np.array([x,y,DS[2]-MinS.Slice])
               m1=np.array([x,y,DS[2]-MaxS.Slice])              
               t=np.array([0.0,0.0,-1.0])              
               up=np.array([0.0,-1.0,0.0])              
               M1=MasterNode(0,m1,0.0,t,up)
               M0=MasterNode(1,m0,0.0,t,up)    
                                         
         else :
            print 'No direction specified for Section:'+str(self.Sections[S].Index)  
         # Rotates polygon point order to match the previous polygon -  not great
         #if S==0:
         #   self.Sections[S].MatchPolygons(MinS.Polygon)
         #else:
         #   self.Sections[S].MatchPolygons(self.Sections[S-1].FindMax().Polygon)
         M0.Index=2*S
         M1.Index=2*S+1 
        #print(M0.Position, M1.Position)
         self.Nodes.Insert(M0)
         self.Nodes.Insert(M1)
         #print 'In yarn: '+str(self.Index)+' and section: '+str(S)+' nodes: '+str(2*S)+','+str(2*S+1)
      # Fix duplicate node issue
      Nodes=self.Nodes
      NodeList=Nodes.GetList([])

      for i in range(Nodes.CountNodes()-1):
         self.Length+=NodeDistance(NodeList[i],NodeList[i+1])
      SecInd=sorted([i for i in self.Sections])
      #print self.Length
      if len(self.Sections)>1:
         PreLength=0 
         for i in range(len(self.Sections)):
           #print(NodeList[2*i].Index,NodeList[2*i+1].Index)
           SecLength=NodeDistance(NodeList[2*i],NodeList[2*i+1])
           self.Sections[SecInd[i]].UpdateGlobalPositions(self.Length,PreLength,SecLength)
           try:
             PreLength+=SecLength+NodeDistance(NodeList[2*i+1],NodeList[2*i+2])
           except IndexError:
             pass  

      if self.right:
        self.right.AddMasterNodes()

   def ExtractSections(self,Index): 

     if isinstance(self.Index, int):
       if Index<self.Index:
          if self.left is None:
             return 'Yarn'+str(Index)+'Not Found'
          return self.left.ExtractSection(Index)
       elif Index>self.Index:
          if self.right is None:
             return 'Yarn'+str(Index)+'Not Found'
          return self.right.ExtractSection(Index)
       else:
          return self.Sections

   def PrintYarnTree(self):

      if self.left:
        self.left.PrintYarnTree()
      print(self.Index)
      if self.right:
        self.right.PrintYarnTree()

   def ExtractYarns(self,EmptyDict={}):
     if self.left:
       self.left.ExtractYarns(EmptyDict) 
     EmptyDict[self.Index]=self  
     if self.right:
       self.right.ExtractYarns(EmptyDict)    
     return EmptyDict

   def CountSlices(self,Count=0):

     if self.left:
        self.left.CountSlices(Count)
 
     for sec in self.Sections:
        Count=self.Sections[sec].CountNodes(Count)
 
     if self.right:
        self.right.CountSlices(Count)
     
     return Count
 
class Section: #Data binary tree for signle direction section sequence - recursive method

  def __init__(self,Index,Slice,Polygon,Direction,Sign):

    self.Index=Index
    self.Slice=Slice
    self.Direction=Direction
    self.d=0.0
    self.Polygon=Polygon
    self.Sign=Sign
    if self.Slice:
       CentrePos=np.sum(Polygon,0)/len(Polygon[:,0])
       if Direction in ['X','x']:
          Position=np.array([Slice,CentrePos[0],CentrePos[1]])
          self.SlaveNode=SlaveNode(Position)
       elif Direction in ['Y','y']:
          Position=np.array([CentrePos[0],Slice,CentrePos[1]])
          self.SlaveNode=SlaveNode(Position)        
       elif Direction in ['Z','z']:   
          Position=np.array([CentrePos[0],CentrePos[1],Slice])
          self.SlaveNode=SlaveNode(Position)   
    else:
       self.SlaveNode=None     
       
    self.left=None
    self.right=None
    
  def Insert(self,Section): #New node in section tree

    if isinstance(self.Slice,float or int):
         if self.Slice>Section.Slice: 

           if self.left==None:
              self.left=Section
           else:
              self.left.Insert(Section)

         elif self.Slice<Section.Slice:

           if self.right==None:
              self.right=Section
           else:
              self.right.Insert(Section)

         elif self.Slice==Section.Slice:
           print('Polygon updated for slice:'+str(Section.Slice)+' in Yarn:'+str(Section.Index))
           self.Polygon=Section.Polygon

    elif self.Slice==None:  
      self=Section


  def UpdatePositions(self,Min,Max):

    if isinstance(self.Slice,float or int):
      if self.left:
        self.left.UpdatePositions(Min,Max) 
      self.d=float((self.Slice-Min))/float((Max-Min))
      if self.right:
        self.right.UpdatePositions(Min,Max)

  def UpdateGlobalPositions(self,YarnLength,PreLength,SecLength): # For entire path
   
    if self.left:
      self.left.UpdateGlobalPositions(YarnLength,PreLength,SecLength) 
    self.d=(PreLength+SecLength*self.d)/YarnLength
    if self.right:
      self.right.UpdateGlobalPositions(YarnLength,PreLength,SecLength)    
  
  def MatchPolygons(self,PreviousPolygon): 
    if self.left:
       self.left.MatchPolygons(self.Polygon)
    self.Polygon=MatchArrays(PreviousPolygon,self.Polygon) 
    if self.right:
       self.right.MatchPolygons(self.Polygon)    
 
  def FindMax(self):
   if isinstance(self.Slice, float or int):
       if self.right: 
          return self.right.FindMax()
       return self

  def FindMin(self):
   if isinstance(self.Slice,float or int):
       if self.left: 
          return self.left.FindMin() 
       return self

  def CountNodes(self,Count=0):
     if self.left:
       Count=self.left.CountNodes(Count)
     Count+=1  
     if self.right:
       Count=self.right.CountNodes(Count)
     return  Count
    
  def TreeToDictionary(self,EmptyDict={}):
     if self.left:
       EmptyDict=self.left.TreeToDictionary(EmptyDict)

     EmptyDict[self.d]=self  

     if self.right:
       EmptyDict=self.right.TreeToDictionary(EmptyDict)
     return  EmptyDict

  def PrintTree(self):
     if self.left:
       self.left.PrintTree()
     print(self.Slice)
     if self.right:
       self.right.PrintTree()  

class MasterNode:

  def __init__(self,Index,Position,Angle,Tangent,Up):
    self.Index=Index
    self.Position=Position
    self.Angle=Angle
    self.Tangent=Tangent
    self.Up=Up
    self.right=None
    self.left=None

  def Insert(self,Node):

    if isinstance(self.Index, int):
       
        if self.Index>Node.Index: 

           if self.left==None:
              self.left=Node
              #print str(self.Index)+' assign left node '+str(Node.Index)
           else:
              self.left.Insert(Node)

        elif self.Index<Node.Index:

           if self.right==None:
              self.right=Node
              #print str(self.Index)+' assign right node '+str(Node.Index)
           else:
              self.right.Insert(Node)

        elif self.Index==Node.Index:
           self.Position=Node.Position
           self.Angle=Node.Angle
           self.Tangent=Node.Tangent
           self.Up=Node.Up
           #print str(self.Index)+' replace node '+str(Node.Index)
    else:

        self=Node

  def GetList(self,Empty=[]):

     if self.left:
        Empty=self.left.GetList(Empty)
     
     Empty.append(self)  
     
     if self.right:
        Empty=self.right.GetList(Empty)    
     
     return Empty

  def Find(self,ind):

    if ind<self.Index:
      if self.left is None:
          return str(ind)+' Not Found'
      return self.left.Find(ind)
    elif ind>self.Index:
       if self.right is None:
          return str(ind)+' Not Found'
       return self.right.Find(ind)
    elif ind==self.Index:
       return self
  
  def CountNodes(self,Count=0):
     if self.left:
       Count=self.left.CountNodes(Count)
     Count+=1  
     if self.right:
       Count=self.right.CountNodes(Count)
     return  Count

  def PrintTree(self):
    if self.left:
      self.left.PrintTree()
    print(self.Index)
    if self.right:
      self.right.PrintTree()

class SlaveNode:
  def __init__(self,Position):
    self.Position=Position


if __name__=='__main__':
  #Get in the appropriate VF folder 
  cwdvf=cwd+'\\VF55'
  os.chdir(cwdvf)
  
  #Get data for window size and resolution:
  
  WinSize=np.genfromtxt('window_size.txt')
  file=open('pixel_size.txt','r')
  ImgRes=file.read() #mm
  file.close()
  ImgRes=float(ImgRes)
  #Define domain
  DS=WinSize*np.array([1.0,1.0,1.0])*ImgRes
  P0=np.array([0.0,0.0,0.0])
  CP2=XYZ(DS[0],DS[1],DS[2])
  CP1=XYZ(P0[0],P0[1],P0[2])
  CDomain=CDomainPlanes(CP1,CP2) # TexGen domain class
  #Polygon Data folder:
  DatFold='\\Data8'
  os.chdir(cwdvf+DatFold)
  # Store Files:
  FileList=[(f.replace('.dat','')).split('_') for f in listdir(cwdvf+DatFold)] # list of info from names
  FileNames=[f for f in listdir(cwdvf+DatFold)] # full names
  # Initialise auxiliary class: 
  MyYarns=Yarns(0)
  i=0
  for file in FileList:
    # File name structure : Direction_YarnIndex_Index_Slice ex. : X_2_1_230 + _-1 depending on the partition sequence. 
    Direction=file[0]
    YarnIndex=int(file[1])
    Index=int(file[2])
    Slice=int(file[3])*ImgRes
    Sign=None
    Polygon=np.genfromtxt(cwdvf+DatFold+'\\'+FileNames[i])*ImgRes
    #Polygon=RotateArray(Polygon,0.5)
    if Direction in ['Z','z']:
       try: 
          Sign=int(file[4])
          Slice=DS[2]-Slice #Reversed Z axis
       except IndexError:
          #Slice=DS[2]-Slice
          pass
       Polygon=Polygon*np.array([1.0,-1.0])+np.array([0.0, DS[1]]) #DS[1]])#([DS[0],DS[1]])
    elif Direction in ['X','x']:
       #Slice=DS[0]-Slice
       Polygon=Polygon*np.array([-1.0,-1.0])+np.array([DS[1],DS[2]])
    elif Direction in ['Y','y']:
       Polygon=Polygon*np.array([1.0,-1.0])+np.array([0.0,DS[2]])#DS[2]])             
    #Populate trees   
    MySection=Section(Index,Slice,Polygon,Direction,Sign)
    MyYarns.InsertSection(YarnIndex,MySection)
    i+=1
  # Add master nodes to join sections and compute final global positions  
  #MyYarns.PrintYarnTree()
  
  MyYarns.AddMasterNodes()
  
  #######
  # TexGen classes initialisation: 
  Textile=CTextile()
  Interpolation=CInterpolationBezier(False, False, False)
  
  #Traverse auxiliary yarn tree and extract yarns
  MyYarnDict=MyYarns.ExtractYarns()
  #Indices used for binder yarns need to be included in a list
  #This helps with identifying and applying the appropriate resolution 
  BinderIndexList=[]#Initialised and populated with yarns with number of partitions>1

  # Iterate yarn class to extact data and populate corresponding TexGen classes
  for y in MyYarnDict:
    MyYarn=MyYarnDict[y]
    MyNodes=MyYarn.Nodes
    NodeList=MyNodes.GetList([])
######  Add extra nodes between partition links 
#    num=len(NodeList)
#    if num>2:
#      for i in range(num//2-1):
#        N0=NodeList[3*i+1]
#         N1=NodeList[3*i+2]
#         dv=N1.Position-N0.Position
#         NmidPos=N0.Position+dv*0.5
#         tan_i=dv/np.linalg.norm(dv)
#         up_i=np.cross(tan_i,np.array([0.0,1.0,0.0]))
#         Nmid=MasterNode(3*i+2,NmidPos,0.0,tan_i,up_i)
#         NodeList.insert(3*i+2,Nmid)
############################# 

    n0y=NodeList[0].Position[1]
    NumSlices=MyYarn.CountSlices(0)
    MySections=MyYarn.Sections
    BinderBool=False
    if len(MySections)>1:
      BinderIndexList.append(y)
      BinderBool=True
    CSection=CYarnSectionInterpPosition()
    CNodeList=[CNode(XYZ(n.Position[0],n.Position[1],n.Position[2])) for n in NodeList]

    for sec in MySections:
      MySection=MySections[sec]
      Direction=MySection.Direction
      index=MySection.Index
      SectionsDict=MySection.TreeToDictionary({})
      Sign=MySection.Sign
      #Local coordinate system:
      # - Adjust transformations accordingly to match the global representation
      for s in SectionsDict:
        CXYVector=XYVector()
        MyPolygon=SectionsDict[s].Polygon
        N=MyNodes.Find(2*sec)
        
        #Append nodes for translation vector computations:
        #if BinderBool and sec==0:
        #   if 

        if Direction in ['X','x']:
          MNPos=np.array([N.Position[1],N.Position[2]])
          #MyPolygon=ClosestIndex(MyPolygon,StartAngleX,MNPos)
          LocPolygon=(MyPolygon-MNPos)*np.array([-1.0,1.0])
          LocPolygon=LocPolygon[::-1] # Fixes hollow rendering (if needed)
        elif Direction in ['Y','y']:
          MNPos=np.array([N.Position[0],N.Position[2]])
          LocPolygon=(MyPolygon-MNPos)*np.array([1.0,1.0])   
          LocPolygon=LocPolygon[::-1]
        elif Direction in ['Z','z']:
          MNPos=np.array([N.Position[0],N.Position[1]])
          #MyPolygon=BringToTop(MyPolygon,3)
          if Sign:
             LocPolygon=(MyPolygon-MNPos)*np.array([1.0, -1.0])
          else:
             LocPolygon=(MyPolygon-MNPos)*np.array([-1.0, -1.0])
             LocPolygon=LocPolygon[::-1]
        else:
          print 'Unrecognised direction'   
        #LocPolygon=RotateArray(LocPolygon,0.9)   
        CXYList=[XY(p[0],p[1]) for p in LocPolygon]
        for i in CXYList:
          CXYVector.push_back(i)
        #d=SectionsDict[s].d
        CSection.AddSection(s,CSectionPolygon(CXYVector))

    CYarn0=CYarn()
    CYarn0.AssignSection(CSection)
    i=0
    for n in CNodeList:
       CYarn0.AddNode(n)
       n0=CYarn0.GetNode(i)
       Up=NodeList[i].Up
       Tangent=NodeList[i].Tangent
       CUp=XYZ(Up[0],Up[1],Up[2])        
       CTangent=XYZ(Tangent[0],Tangent[1],Tangent[2])
       try:
         n0.SetTangent(CTangent)
         n0.SetUp(CUp)
       except AttributeError:
         pass
       i+=1

    CYarn0.AssignInterpolation(Interpolation)
    # Adjusted resolution depending on yarn type. 
    #Original:
    #if BinderBool:
    #  CYarn0.SetResolution(int(NumSlices*0.6),50)
    #else:
    #  CYarn0.SetResolution(int(NumSlices*0.8),80) 

    if BinderBool:
      CYarn0.SetResolution(int(NumSlices*0.6),20)
    else:
      CYarn0.SetResolution(int(NumSlices*0.8),40)

    Textile.AddYarn(CYarn0)
